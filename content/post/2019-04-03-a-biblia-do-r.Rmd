---
title: A Bíblia do R
author: Michelangelo R. dos Anjos
date: '2019-10-29'
slug: a-biblia-do-r
categories:
  - R
  - Turoriais
tags:
  - R
  - Code
  - Basic
  - Tutorial
editor_options: 
  chunk_output_type: console
output:
  blogdown::html_page:
    toc: true
---

## 1. Introdução

<a name="abcd"> Esse </a> é o primeiro post e o que eu considero o principal e mais importante, pois a ideia de criação do site surgiu por causa de um backup de códigos que eu criei conforme as necessidades iam aparecendo e carregava ele comigo para todo lado para consultar quando precisava. Dessa forma, decidi organizá-lo melhor, upar na internet para facilitar o acesso e compartilhar com mais pessoas que tenham interesse e espero que possa ser útil para mais alguém como é muito importante para mim (já que minha memória não é das melhores :laughing:).

O post estará em constante atualização, pois sempre surge algo novo para aprendermos e a ideia é passar a linguagem R para frente sempre de maneira simples e didática, talvez a organização não fique a das melhores, mas vou procurar me esforçar ao máximo, caso o sumário não fique muito claro, recomendo utilizar o **"Ctrl F"** que sempre me salvou e pode ajudar vocês também.

Por último, antes de começar realmente os códigos, vocês encontraram meio misturado códigos **dplyr** com o **R raiz**, mas será em momentos na qual os códigos possuem a mesma função mas simplesmente podem ser escritos em estruturas diferentes. Acho muito importante saber as diversas maneiras de programar pois existem horas que uma será mais fácil que a outra. Por exemplo, na minha opinião, o **R raiz** é mais fácil para programar rotinas, loop, for, if, while, etc. Já o **dplyr** é mais fácil para acessar, consultar, agrupar, exibir resultados de uma tabela.

[Volte ao topo](#abcd)

***

## 2. Funções de configuração e ajuda.

Antes de começar de fato a entrar na linguagem R, vou deixar algumas funções de configuração e ajuda no R que também são muito importantes e costumo utilizar bastante no dia a dia.

### 2.1. Alterando o formato que as saídas são exibidas.

*Parametros:*

* scipen e digits.

Esses dois parâmetros são os que mais utilizo nas configurações do R, antes mesmo de começar a programar. 

+ O primeiro **scipen** especifica qual saída queremos exibir para os números, se a ciêntifica $e^{10}$ ou os números completos.
+ O segundo **digits** especifica a quantidade de digitos que queremos exibir.

OBS: O número no parâmetro não importa para o **scipen**, apenas o sinal.

* scipen.
+ Negativo: Linguagem ciêntifica é exibida.
+ Positivo: O número é exibido inteiro.

* digits.
+ Número de digitos.

```{r}
options(scipen = -9999, digits = 3)
```

```{r,echo=FALSE}
cat("Saída exibida: ",2.575757575757)
```

```{r}
options(scipen = 1111, digits = 6)
```

```{r,echo=FALSE}
cat("Saída exibida: ",2.575757575757)
```

* datatable.integer64.

```{r}
options(datatable.integer64="numeric")
```

Para que na leitura dos dados utilizando o pacote data.table, o R não entenda valores numéricos como integer64 e sim como numeric.

### 2.2. Funções de ajuda.

Quando queremos saber informações sobre determinada função no R podemos utilizar o comando **help** ou a abreviação **?**.

```{r, eval=FALSE}
help(mean)
?mean
```

Em algumas ocasiões não lembramos o nome da função inteira, apenas uma parte. Ao utilizar o comando **apropos** o **R** lista funções que tem a parte especificada no nome.

```{r}
apropos('mea')
```

Por último e de muita utilidade, conseguimos verificar os símbolos operacionais matemáticos que o **R** utiliza apenas com o comando abaixo.

```{r, eval=FALSE}
help('*')
```

```{r,echo=FALSE}
cat("Saída exibida no Help:
+ x
- x
x + y
x - y
x * y
x / y
x ^ y
x %% y
x %/% y")
```


[Volte ao topo](#abcd)

## 3. Atalhos úteis

* Seleção vertical.
+ Para realizar esse tipo de seleção segure **alt** apertado e selecionando com o mouse, fazemos seleção vertical e podemos alterar tudo de uma vez.
+ Além disso combinamos algumas teclas para facilitar. Ao selecionar verticalmente com o **alt**, apertando **shift + end** o cursor vai para o fim de todas as linhas selecionadas, ou **shift + home** para o cursor ir para o início da linha. Outra possibilidade é utilizar as setas para o lado para selecionar, na maioria das vezes é isso que eu utilizo **shift + -> ou <- **.

* Substituindo palavras no R.
+ Apertando ctrl F assim como no excel, conseguimos substituir todas palavras de uma vez

*Parametros:*

1 - **In selection:** substitui apenas no local selecionado

2 - **Match case:** diferencia maiuscula de minuscula

3 - **Regex:** entende o comando **|** como se fosse **ou**, ou seja operador lógico.

* Refazendo uma ação.
+ Muitos sabem que o **ctrl + z** desfaz uma ação no R, mas em alguns casos acabamos desfazendo mais do que queriamos, para **refazer** algo desfeito existe o comando **ctrl + shift + z** que você pode alterar em **Tools - Modify Keyboard Shortcuts**, o mais utilizado em geral para refazer caso queira alterar é o **ctrl + i**. Outros atalhos também podem ser configurados nessa janela.

[Volte ao topo](#abcd)

## 4. Comandos base úteis.

* Limpando a memória do R.
+ Quando trabalhamos com **loop** ou um código muito grande que vai gerando bases temporrárias pesadas, isso vai sobrecarregando a memória do R, tempos alguns comandos que podem nos ajudar nisso, são eles: **objects**, **ls** e **rm**, .

O comando **objects** e **ls** lista os objetos criados até o momento no R.

```{r,eval=FALSE}
objects()
ls()
```

Já o comando **rm** limpa os objetos criados no R. É possível remover *TODOS* os objetos criados, combiando o comando **rm** com **ls** como vemos abaixo.

```{r,eval=FALSE}
rm(list = ls())
```

Ou podemos excluir apenas alguns objetos de interesse, por exemplo.

```{r,eval=FALSE}
objeto1 = c()
objeto2 = c()
rm(objeto1, objeto2)
```

* Verificando e alterando diretórios.
+ Para verificiar o diretório que estamos trabalhando no R, onde serão salvos os arquivos, as bases entre outras coisas, utilizamos o comando **getwd**. 
+ Para alterar o caminho de um diretório para uma pasta de um projeto específico por exemplo, utilizamos o **setwd**. Outro detalhe é que para especificarmos um caminho no R não utilizamos as barras padrão do windows **C:\\** mas sim as barras duplas, como mostra o exemplo abaixo, ou até mesmo a barra invertida **C:/**

```{r, eval=FALSE}
getwd()
setwd("C:\\Users")
```

* Salvando e carregando arquivos do tipo RData.
+ Os objetos no R podem ser salvos utilizando o comando **save** e carregados utilizando o comando **load**. 
+ **save** - O primeiro parâmetro é o nome do objeto a ser salvo (pode ser mais do que um) e o segundo o diretório que ele será salvo (se não especificar salvará no que já esta configurado) seguido do nome do objeto e sua extenção do r **RData**.
+ **load** - O parâmetro necessário é o diretório que o objeto está salvo seguido do seu nome e sua extenção **RData**.

```{r, eval=FALSE}
objeto1 = c()
objeto2 = c()

save(objeto1,objeto2, file = "C:\\Users\\objeto1.RData")
load(file = "C:\\Users\\objeto1.RData")
```


* Instalando, carregando e descarregando pacotes
+ Para instalar um pacote usamos o **install.packages**
+ Para carregar um pacote usamos o **library**. 
+ Para descarregar um pacote usamos o **detach** ele apenas descarrega o pacote caso o mesmo tenha sido carregado com o **library**.

```{r,eval=FALSE}
install.packages("pacote")
library(pacote)
detach(package:pacote)
```


Não precisamos necessariamente carregar um pacote, basta chamá-lo pelo nome, seguido de **::** e em seguida a função que desejamos utilizar dele, por exemplo:

```{r, eval=FALSE}
dplyr::select()
```

* Verificando os pacotes instalados

Pode não parecer útil, mas em algum momento pode se tornar. O comando abaixo lista todos os pacotes instalados na versão do R que você está utilizando.

```{r,eval=FALSE}
rownames(installed.packages())
```

É muito útil quando criamos funções na qual possui pacotes depententes, nesse caso, verificamos se o pacote está instalado, caso não esteja, instalamos.

```{r,eval=FALSE}
if("pacote" %in% rownames(installed.packages()) == FALSE){
  install.packages("pacote")
}
```

Outra utilidade é quando vamos atualizar o R ou mudar de computador e acabamos perdendo todos os pacotes. Antes de fazer essa alteração de versão ou de computador, podemos rodar o seguinte comando no computador/versão antiga:

```{r,eval=FALSE}
packages = c("gdata",rownames(installed.packages()))
save(packages, file="C:/Temp/Rpackages")
```

Na qual criamos a pasta **temp** anteriormente no nosso computador, salvamos todos os pacotes salvos no objeto **packages** e salvamos esse objeto em nossa pasta **temp**.

Ao trocar de computador/versão, carregamos essa pasta com a gente e usamos o comando para instalar todos os pacotes que estavam instalados para nós.

```{r, eval=FALSE}
load(file = "C:/Temp/Rpackages")
for (p in setdiff(packages, rownames(installed.packages()))){
  install.packages(p)
}
```

* <a name="condicionais">Condicionais no R.</a>
+ **=**  (recebe)
+ **==** (igual)
+ **!=** (diferente)
+ **>**  (maior)
+ **<**  (menor)
+ **>=** (maior igual)
+ **<=** (menor igual)
+ **%in%** (contido)

## 5. Estrutura e criação de objetos.

Os objetos mais utilizados no R por mim pelo menos são vetores, matrizes, data frames e listas, irei mostrar a estrutura de cada um deles e como acessar seus elementos. Para atribuir uma variável a um objeto utilizamos as teclas **<-** ou **=** fica a sua escolha.

### 5.1. Vetores

* Criando um vetor

Para criar um vetor utilizamos a função **c()**:

```{r}
vet_1 = c(7,2,5,9,7)
vet_2 = c("a","b","c")
vet_3 = c(1,"a",5)
vet_4 = c(17,12,15,19,17)
```

* Acessando elementos de um vetor

Para acessar os elementos de um vetor é simples, basta utilizar o comando **[]** sendo que dentro dele especificamos qual o índice do vetor queremos acessar. Por exemplo, se queremos verificar qual o segundo elemento do vetor 1 **vet_1**, fazemos **vet_1[2]**.

Eu leio esse comando como se fosse **onde**, isso me ajuda muito na parte de filtragem e seleção de dados que veremos mais para frente. Meu conselho então é sempre que ver o símbolo **[]** ler **onde**. Por exemplo **vet_1[2]** leia **vet_1 onde a posição é 2**.

```{r,eval=FALSE}
vet_1[2]
```

```{r,echo=FALSE}
cat("Saída exibida: ",vet_1[2])
```

* Nomeando elementos de um vetor

Em alguns casos é útil nomear os elementos de um vetor, por exemplo

```{r}
names(vet_1) = c('um','dois', 'tres','quatro','cinco')
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1
```

Dessa forma, podemos acessar os elementos dos vetores através do seu nome e começamos introduzir outro conceito que é o de camadas, muito utilizados em listas que iremos ver mais para frente. Temos duas camadas agora então, o título com o conteúdo de cada elemento na primeira camada e o somente o conteúdo daquele elemento na segunda camada.

A primeira camada já vimos como acessar, que é utilizando o comando **[]**, para a segunda camada, basta utilizarmos duas vezes esse comando **[[]]** pronto.

Acesso a primeira camada do primeiro elemento com o título e conteúdo:

```{r,eval=FALSE}
vet_1[1]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[1]
```

Acesso a segunda camada do primeiro elemento com o conteúdo:

```{r, eval=FALSE}
vet_1[[1]]
```

```{r,echo=FALSE}
cat("Saída exibida: ",vet_1[[1]])
```

* Filtrando elementos de um vetor

Para filtrar valores dentro de um vetor utilizamos as condicionais exemplificadas [AQUI](#condicionais), ou até mesmo para comparar e fazer verificações se um vetor é igual ao outro.

* Retornando valores dentro do vetor que são iguais a 7

```{r,eval=FALSE}
vet_1[vet_1 == 7]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[vet_1 == 7]
```

* Retornando valores dentro do vetor que são menores do que 7

```{r,eval=FALSE}
vet_1[vet_1 < 7]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[vet_1 < 7]
```

Outra verificação que podemos fazer é o tamanho do vetor, através da função **length**, ou seja, quantos elementos tem dentro daquele objeto vetor.

```{r, eval=FALSE}
length(vet_1)
```

```{r, echo=FALSE}
cat("Saída exibida: ", length(vet_1))
```

Algumas funções facilitam bastante nossa vida na hora de criar vetores, por exemplo, **vetores de repetição**, **aleatórios** e **sequenciais**

* Excluindo itens de um vetor

Temos basicamente duas formas de fazer isso.

A primeira é colocando o sinal de menos antes da posição do item no vetor que queremos excluir, no exemplo abaixo o item na posição 2, equivalente ao valor 12.

```{r, eval=FALSE}
vet_4[-2]
```

```{r, echo=FALSE}
cat("Saída exibida: ", vet_4[-2])
```

A segunda é filtando o elemento que não queremos

```{r, eval=FALSE}
vet_4[vet_4 != "12"]
```

```{r, echo=FALSE}
cat("Saída exibida: ", vet_4[vet_4 != "12"])
```

Ou se queremos excluir mais de um item usamos o condicional %in% com a exclamação antes do vetor, indicando que queremos os itens do vetor que não estão contidos naquele intervalo de valores

```{r, eval=FALSE}
vet_4[!vet_4 %in% c(12,17)]
```

```{r, echo=FALSE}
cat("Saída exibida: ", vet_4[!vet_4 %in% c(12,17)])
```

* Vetores de repetição

Repetindo a sequencia de 1 a 5 duas vezes

```{r,eval=FALSE}
rep(1:5, 2)
```

```{r,echo=FALSE}
cat("Saída exibida: ", rep(1:5, 2))
```

Repetindo os números de 1 a 5 duas vezes

```{r,eval=FALSE}
rep(1:5, each=2)
```

```{r,echo=FALSE}
cat("Saída exibida: ", rep(1:5, each=2))
```

* Gerando números aleatorios de acordo com algumas distribuições.

10 números aleatórios normais com média 0 e desvio padrão 1.

```{r}
rnorm(10, mean = 0, sd = 1)
```

10 números aleatórios com distribuição poisson com número esperado de ocorrências e variância iguais a 3.

```{r}
rpois(10,3) #poisson
```

Para a binomial temos algumas situações, primeiros podemos querer realizar 400 jogos, onde cada jogo tem 10 lançamentos de moeda, cuja probabilidade de sucesso é 0.5. Nesse caso esperamos que em média, o número de sucessos seja aproximadamente 5, como modemos ver abaixo:

```{r,eval=FALSE}
rbinom(400, 10, 0.5)
```

```{r}
mean(rbinom(400, 10, 0.5))
```

Dessa forma se fizemos uma rodada de lançamento de moedas, onde cada rodada tem 10 jogos e somamos o número de sucessos com probabilidade 0.5 cada, tem o mesmo valor esperado do que somar 10 rodadas com 1 lançamento cada, cuja resposta é 0 para fracasso e 1 para sucesso e com probabilidade 0.5 de sucesso em cada lançamento.

```{r,eval=FALSE}
rbinom(1, 10, 0.5)
```

```{r,echo=FALSE}
cat("Saída exibida: ", rbinom(1, 10, 0.5))
```

```{r,eval=FALSE}
sum(rbinom(10, 1, 0.5))
```

```{r,echo=FALSE}
cat("Saída exibida: ", sum(rbinom(10, 1, 0.5)))
```

Mais usual é gerar números aleatórios com a mesma probabilidade de sucesso utilizando a distribuição uniforme, nesse casos podemos gerar 10 números na qual o mínimo é 1 e o máximo é 10.

```{r}
runif(10,min = 1, max = 10) #uniforme 
```

```{r,echo=FALSE}
cat("Saída exibida: ", runif(10,min = 1, max = 10))
```

A mesma lógica pode ser usada mas agora gerando apenas números inteiros através da função sample, gerando 10 números de -10 a 10.

```{r,eval=FALSE}
sample(-10:10, 10)
```

```{r,echo=FALSE}
cat("Saída exibida: ", sample(-10:10, 10))
```

Além disso, utilizando o parâmetro **replace** podemos repetir números

```{r,eval=FALSE}
sample(0:10, 10,replace = T)
```

```{r,echo=FALSE}
cat("Saída exibida: ", sample(0:10, 10,replace = T))
```

Com esse comando podemos sortear nomes também. Para isso, basta criarmos um vetor de nomes, fora ou dentro do comando, e especificar quantos nomes queremos que seja sorteados.

```{r,eval=FALSE}
sample(c("João","Maria","José","Pedro","Julieta"), 2)
```

```{r,echo=FALSE}
cat("Saída exibida: ", sample(c("João","Maria","José","Pedro","Julieta"), 2))
```

* Vetores sequenciais pulando de acordo com o intervalo desejado.

Muito útil também é gerar valores sequencias pulando uma determinada quantia de valores, para isso, usamos a função **seq**, onde queremos gerar valores de 1 a 10, pulando de 0.5 em 0.5 sequencialmente.

```{r,eval=FALSE}
seq(1,10,0.5)
```

```{r,echo=FALSE}
cat("Saída exibida: ", seq(1,10,0.5))
```

* Criando uma semente para os valores aleátorios.

Em muitas situações queremos replicar estudos de simulação com valores aleatórios, para isso, podemos criar uma semente, e dessa maneira os números aleatórios iram se repetir até mesmo em outro computador. O comando que faz isso é o **set.seed**, onde o parâmetro dentro da função tem que ser o mesmo nas replicações.

```{r}
set.seed(57)
```

* Operações com vetores

Podemos realizar operações com vetores, como somar, subtrair, multiplicar e dividir.

```{r,eval=FALSE}
vet_1 + vet_4
vet_1 - vet_4
vet_1 * vet_4
vet_1 / vet_4
4 * vet_1
```

### 5.2. Matrizes

Matrizes seguem a mesma lógica de vetores, porém, com mais dimensões, nós trabalharemos sempre com matrizes de duas dimensões, para criar a matriz, elas também são Semelhante ao data.frame, exceto que cada elemento deve ser o mesmo tipo e mais comumente todos sendo números. As funções que funcionam com data.frame também devem funcionar com a matriz. Eu particularmente utilizo matrizes apenas em funções como for, while, para ir preenchendo, em geral utilizo mais data.frames

* Sintaxe para criação de matrizes

Para criar matrizes é simples e tem diversas maneiras. A primeira é no primeiro parâmetro adicionar o vetor de valores, o segundo parâmetro o número de linhas e o terceiro parâmetro o número de colunas.

```{r}
matrix1 = matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3,ncol = 3)
```

```{r,echo=FALSE}
cat("Saída exibida:")
matrix1
```

O segundo jeito é especificar somente o vetor de valores e o segundo parâmetro que é o número de linhas de cada coluna, dessa forma, os valores vão se alocando sozinhos na primeira coluna até o quinto elemento por exemplo e depois vão para a segunda.

```{r}
matrix2 <- matrix(1:10, nrow = 5)
```

```{r,echo=FALSE}
cat("Saída exibida:")
matrix2
```

Geralmente nos looping criamos inicialmente uma matriz de NA, para isso, basta deixarmos o primeiro parâmetro vazio

```{r,echo=FALSE}
matrix3 <- matrix(,nrow = 3,ncol = 3)
```

```{r}
cat("Saída exibida:")
matrix3
```

Como vimos por padão o R vai adicionando os elementos por linha, podemos alterar isso para colunas adicionando o parâmetro **byrow**

```{r}
matrix4 <- matrix(1:10, nrow = 5, byrow = TRUE)
```

```{r,echo=FALSE}
cat("Saída exibida:")
matrix4
```

* Multiplicando de matrizes

Para multiplicar matrizes utilizamos o operador %*%.

```{r, eval=FALSE}
matrix1 %*% matrix1
```

* Transpor matrizes

Para transpor uma matriz basta usar a função **t()**

```{r,eval=FALSE}
t(matrix1)
```

* Acessando elementos de uma matriz

Para acessar elementos de uma matriz é muito simples, assim como vetor, usamos operador **[]**, porém em uma matríz temos linhas e colunas e para separar isso, vamos utilizar uma vírgula, ficando o operador dessa forma **[,]**. Antes da vírgula é o acesso a linha e depois da vírgula é o acesso a coluna.

Dessa forma, para acessar a primeira linha de uma matriz utilizamos **[1,]**.

```{r, eval=FALSE}
matrix1[1,]
```

```{r,echo=FALSE}
cat("Saída exibida: ", matrix1[1,])
```

Para acessar a primeira coluna de uma matriz utilizamos **[,1]**

```{r,eval=FALSE}
matrix1[,1]
```

```{r,echo=FALSE}
cat("Saída exibida: ", matrix1[,1])
```

Para acessar um elemento da matriz passamos as coordenadas, por exemplo, queremos o elemento que está na primeira linha da segunda coluna, fazemos então **[1,2]**.

```{r,eval=FALSE}
matrix1[1,2]
```

```{r,echo=FALSE}
cat("Saída exibida: ", matrix1[1,2])
```

Esses conceitos de acesso são muito importantes e você vai utilizar o tempo todo no R, para vetores, matrizes, data.frames e listas.

[Volte ao topo](#abcd)

### 5.3. Tipos de objetos

Ja vimos alguns tipos de objetos que o R possui, vetores e matrizes. Dentre os vetores podemos ter 3 tipos principais, **numeric**, **character** e **factor**. Temos as matrizes que basicamente são conjuntos de vetores e alguns principais que veremos mais para frente que são **data.frames** e **lists**. Mas como saber que tipo de objeto estamos trabalhando? Para isso o R possui uma função chamada **class**. Observe:

* Vetor numérico

```{r,eval=FALSE}
class(c(1,2,3,4,5))
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(c(1,2,3,4,5)))
```

Podemos arredondar valores numéricos utilizando algumas funções no R, as mais comuns são:

* **round** (Arrendondamento tradicional)

Podemos especificar no segundo argumento o número de casa decimais que queremos e onde ele irá arredondar.

```{r}
round(1.5757, 2)
```

* **trunc** (Corta as casas decimais)

```{r}
trunc(1.5757)
```

* **ceiling** (Arredonda o valor pra cima)

```{r}
ceiling(1.5757)
```

* **floor** (Arredonda o valor pra baixo)

```{r}
floor(1.5757)
```

* Vetor character

Quando misturamos numeros com letras, o R entende como vetor de caracteres. Caso o vetor seja convertido para numeric, os caracteres assumirão valores nulos.

```{r,eval=FALSE}
class(c("a","b","1","3"))
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(c("a","b","1","3")))
```

* Vetor factor

É um tipo de vetor para lidar com variáveis categóricas. Ele facilita a ordenação de vetores de textos e são muito utilizados em modelagens, criação de gráficos, etc.

```{r,eval=FALSE}
class(factor(c("a","b","1","3")))
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(factor(c("a","b","1","3"))))
```

Para sabemos quantos níveis/levels tem um vetor de fator, usamos a função **nlevels** que seria basicamente o mesmo do que contar os valores únicos de um vetor de caracteres. Observe abaixo que temos 4 elementos no vetor mas apenas 3 níveis.

```{r}
nlevels(factor(c("a","a","1","3")))
```

* Matrizes

```{r,eval=FALSE}
class(matrix())
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(matrix()))
```

* Data frames

Data frames nada mais são do que tabelas, com linhas e colunas. é praticamente uma matriz com rótulos de colunas. Também são conjunto de vetores, mas diferente de matrizes, cada coluna pode ser um tipo, por exemplo, a coluna 1 pode ser numérica, a coluna 2 pode ser character e a coluna 3 pode ser fator, na matriz ou são numericos ou são caracteres, não temos essa mistura e convenhamos, essa mistura é o que mais ocorre na vida real, pois temois informações como UF, Sexo, Idade, Peso, tudo junto em uma mesma tabela.

```{r,eval=FALSE}
class(data.frame())
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(data.frame()))
```

Porém, em um data.frame quando temos muitas colunas, fica praticamente inviável ficar dando um **class** uma por uma, pensando nisso o R possui uma função chamada **str** que nos mostra os tipos de de cada coluna.

```{r}
df_class = data.frame(col1 = c(7,2,7,56), col2 = c("a","b","c","d"))
```

```{r}
str(df_class,list.len=ncol(df_class))
```

Porém essa não é uma forma muito apresentavel de se ver, podemos fazer uso de outras funções para verificarmos o tipo de cada coluna, caso queiramos filtrar e verificar quais são numéricas, coisas do tipo.

```{r}
Class_DF = data.frame(Variavel = names(sapply(df_class, class)),
                      Classe  = sapply(df_class, class))

row.names(Class_DF) = NULL

```

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE}
Class_DF
```

* Listas

A lista, é um objeto que aceita diversos tipos de objetos dentro dela. Por exemplo, o primeio item de uma lista pode ser um vetor, o segundo pode ser um data.frame, o terceiro pode ser uma matriz e assim por diante.

```{r,eval=FALSE}
class(list())
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(list()))
```

Veremos listas e data.frames de forma mais detalhada em capitulos específicos, pois são os tipos de objetos mais trabalhados, pelo menos comigo.

## 6. Operações matemáticas básicas

Temos abaixo as mais funções matemáticas/estatísticas básicas mais utilizadas, tais como: **log na base e**, **exponencial**, **máximo**, **mínimo**, **soma**, **média**, **mediana**, **variância**, **desvio padrão** e **correlação**, respectivamente:

```{r,eval=FALSE}
log(1)
exp(1)
```

O máximo e mínimo pode ser calculado entre mais de um vetor
```{r,eval=FALSE}
max(vet_1)
max(vet_1,vet_4)

min(vet_1)
min(vet_1,vet_4)
```

```{r,eval=FALSE}
sum(vet_1)
mean(vet_1)
median(vet_1)
var(vet_1)
sd(vet_1)
```

Para a correlação pode ser especificada qual metodologia para calcular, **pearson**, **kendall** ou **spearman**.
```{r,eval=FALSE}
cor(vet_1,vet_4, method = "pearson")
cor(vet_1,vet_4, method = "kendall")
cor(vet_1,vet_4, method = "spearman")
```

[Volte ao topo](#abcd)

```{r}
class(vet_1)
class(vet_2)
class(vet_3)
class(vet_4)
```

Transformando valores de um vetor em factor, numeros e caracteres

```{r,eval=FALSE}
as.factor(vet_1)
as.numeric(vet_2)
as.character(vet_3)
```

## 7. Exibindo valores e textos na tela

Temos algumas opções, as que eu mais utilizo são:

* CAT.

```{r}
cat("Hello World \nLinha de baixo")
```

OBS: O comando \n pula linha

* PRINT.

```{r}
print("Hello World")
```

* WARNING.

```{r}
warning("Hello World")
```

## 8. Data Frames

### 8.1. Criando um Dataframe

Dataframes nada mais são do que um conjunto de vetores, basicamente é uma matriz de duas dimensões, porém de fácil manipulação. Para criar um dataframe, existe diversas maneiras, podemos criar a partir de vetores ja existentes:

```{r}
v1 = c(7,2,7,56)
v2 = c(4,5,6,7)

df1 = data.frame(col1 = v1, col2 = v2)
```

```{r,echo=FALSE}
df1
```

Ou especificar no próprio dataframe os valores

```{r}
df2 = data.frame(col3 = c(7,2,7,56), 
                 col4 = c(1,2,3,4))
```

```{r,echo=FALSE}
df2
```

### 8.2. Acessando elementos de um dataframe

A estrutura de um dataframe é no formato de linha e coluna, e agora, aquele conceito de **onde** baseado em colchetes que foi apresentado anteriormente fará muito sentido. Considere a estrutura **[,]** antes da vírgula temos acesso a linhas de um dataframe e depois da linha temos acesso a colunas. Irei mostrar algumas formas distintas de acessar os elementos com o mesmo resultado

Vamos considerar o dataframe abaixo como exemplo

```{r,echo=FALSE}
df2
```

Vamos acessar a primeira coluna desse dataframe, podemos usar a esturutra de colchetes único, como usamos no vetor. Vale ressaltar que estamos acessando a **COLUNA** e não o **CONTEÚDO** dessa coluna

```{r}
df2[1]
```

Se quisemos acessar o **CONTEÚDO** dessa coluna, podemos usar dois colchetes

```{r}
df2[[1]]
```

Ou o mais usual, usamos a estrutura de colchetes de linha e coluna, passando o parâmetro **APÓS** a vírgula, que significa que vamos acessar todos as linhas da coluna 1

```{r}
df2[,1]
```

Ou a estrutura de **$** chamando o nome da coluna

```{r}
df2$col3
```

Podemos também acessar todas as colunas da linha 1, assim, basta fazermos o contrário, colocarmos o parâmetro **ANTES** da vírgula

```{r}
df2[1,]
```

E ai vamos usando as combinações, podemos acessar a segunda linha da segunda coluna desse dataframe e assim por diante

```{r}
df2[2,2]
```

Isso é muito importante ficar gravado para trabalhar com dataframes

### 8.3. Exibindo dataframes

Temos algumas formas de visualizar os dataframes, para isso vamos usar como exemplo a tabela **mtcars** nativa do R.

Podemos visualizar a tabela usando o **View**, no R abrira uma aba exibindo o dataframe.

```{r,eval=FALSE}
View(mtcars)
```

As vezes é interessante ver apenas as primeiras linhas de um dataframe, nesse caso usamos a função **head**

```{r}
head(mtcars, n = 5)
```

Ou queremos ver as últimas linhas de um dataframe, então usamos a função **tail**

```{r}
tail(mtcars, n = 3)
```

### 8.4. Informações de um dataframe

* Número de linhas

```{r}
nrow(mtcars)
```

* Número de colunas

```{r}
ncol(mtcars)
```

* Dimensão

```{r}
dim(mtcars)
```

* Tamanho de uma coluna específica

```{r}
length(mtcars[,2])
```

* Estatísticas básicas

```{r}
summary(mtcars)
```

* Tipo de variáveis de um dataframe

Já vimos anteriormente alguns métodos. Para verificar os tipos de variáveis de um dataframe, podememos usar a function **str**, porém se o banco de dados é muito grande, ela será truncada, para visualizar o banco todo, usamos o parâmentro **list.len**

```{r}
str(iris,list.len=ncol(iris))
```

Caso queira apenas os tipos das variaveis mesmo, podemos usar a seguinte lógica

```{r}
data.frame(Class = sapply(iris, class))
```

* Nome das colunas

```{r}
colnames(iris)
```

Podemos usar isso para alterar o nome de uma coluna especifica

```{r}
colnames(iris)[2] = "novo_nome"
colnames(iris)
```

Ou de todas as colunas

```{r}
colnames(iris) = c("col1","col2","col3","col4","col5")
colnames(iris)
```

* Nome das linhas

```{r}
rownames(head(iris))
```

Também podemos alterar o nome das linhas usando a mesma lógica

```{r}
rownames(iris)[1] = "linha_1"
rownames(head(iris))
```

### 8.5. Adicionando colunas

Para adicionar colunas podemos usar a estrutura de **$** na qual ja passamos o nome da nova coluna, nesse caso **col5**

```{r}
df2$col5 = c("a","b","c","d")
```

```{r,echo=FALSE}
df2
```

Ou usarmos a estrutura de colchetes único, que já vimos que representa **COLUNA** e passamos o **CONTEÚDO** dessa coluna, nesse caso como não damos um nome, por padrão será **V** acompanhado do número da coluna

```{r}
df2[4] = c(3,2,1,2)
```

```{r,echo=FALSE}
df2
```

Podemos transformar o nome das linhas do nosso dataframe em uma coluna do mesmo

```{r}
head(cbind(linhas = rownames(iris), iris))
```

O contrário também é valido, podemos transformar uma coluna especifica em nosso rownames, desde que não seja duplicada

```{r, eval=FALSE}
rownames(dataframe) = dataframe[,5]
```

### 8.6. Adicionando linhas

Seguindo a mesma lógica das colunas, podemos adicionar linhas, mas indicando o parâmetro após a vírgula referente a posição da linha que deseja inserir e atribuindo o conteúdo a ela

```{r}
df2[5,] = c(1,2,"e",5)
```

```{r, echo=FALSE}
df2
```

### 8.7. Unindo dataframes

Podemos também juntar dois dataframes, tanto em linhas quanto em colunas, para colunas usamos a funçao cbind

```{r}
cbind(df1,df2[-5,])
```

Para colunas usamos a função rbind, caso as colunas tenham o mesmo nome

```{r}
union_df1 = data.frame(col3 = c(7,2,7,56), 
                       col4 = c(1,2,3,4))
union_df2 = data.frame(col3 = c(7,2,7,56), 
                       col4 = c(1,2,3,4))
rbind(union_df1,union_df2)
```

Caso as colunas tenham nomes distintos podemos usar a função bind_rows do pacote dplyr, ela preenche com NA os valores que não tem no outro dataframe

```{r}
dplyr::bind_rows(df1,df2)
```

### 8.8. Excluindo/Filtrando/Selecionando colunas

Temos diversas formas de fazer isso, vamos criar um dataframe com o que foi aprendido até agora para usarmos como base para os exempos

```{r}
del_fil_sel_col = data.frame(Coluna1 = seq(1,100,1),
                             Coluna2 = sample(500,100),
                             Coluna3 = rnorm(100),
                             Coluna4 = rpois(100,3),
                             Coluna5 = runif(100),
                             Coluna6 = rep(1:5, 20))
```

Vamos ver as primeiras linhas desse dataframe gerado

```{r}
head(del_fil_sel_col)
```

A primeira forma que vamos ver aqui é a mais simples, basta atribuirmos o valor **NULL** para a coluna e ela será excluida do dataframe, simples, objetivo, útil e prático.

```{r}
del_fil_sel_col$Coluna6 = NULL
```

Observe que a Coluna6 não está mais no dataframe, essa forma é um caminho sem volta, pois uma vez atribuido o valor **NULL** para a coluna, ela já está deletada

```{r,echo=FALSE}
head(del_fil_sel_col)
```

As demais formas, para que a coluna seja realmente excluída, é necessário salvá-la em cima do mesmo dataframe ou em um novo como preferir

A próxima forma é utilizar a sintaxe de colchetes linhas e colunas, para excluir a coluna desejada basta adicionar o sinal de menos antes da posição da coluna

```{r,eval=FALSE}
del_fil_sel_col[,-5]
```

```{r,echo=FALSE}
head(del_fil_sel_col[,-5])
```

Uma outra forma é usar a função **subset** selecionando ou apenas as colunas que deseja ficar, ou adicionando o sinal de menos antes do vetor, as que deseja excluir. Nessa forma você pode passar tanto o nome da coluna como a sua posição, o resultado é o mesmo

No caso abaixo, queremos excluir a primeira e a segunda coluna, passando o nome delas

```{r, eval=FALSE}
subset(del_fil_sel_col, select = -c(Coluna1,Coluna2))
```

```{r,echo=FALSE}
head(subset(del_fil_sel_col, select = -c(Coluna1,Coluna2)))
```

Agora podemos passar a posição delas

```{r, eval=FALSE}
subset(del_fil_sel_col, select = -c(1,2))
```

```{r}
head(subset(del_fil_sel_col, select = -c(1,2)))
```

Podemos selecionar as colunas que queremos manter, basta retirarmos o sinal de menos antes do vetor.

Nos exemplos abaixo, queremos manter a Coluna1 e Coluna2, primeiro passando o nome das colunas

```{r, eval=FALSE}
subset(del_fil_sel_col, select = c(Coluna1,Coluna2))
```

```{r}
head(subset(del_fil_sel_col, select = c(Coluna1,Coluna2)))
```

Ou novamente passando a posição

```{r, eval=FALSE}
subset(del_fil_sel_col, select = c(1,2))
```

```{r}
head(subset(del_fil_sel_col, select = c(1,2)))
```

Isso também pode ser feito utilizando o pacote **dplyr** passando a posição

```{r,eval=TRUE, message=FALSE, warning=FALSE, include=TRUE}

library(dplyr)

head(del_fil_sel_col %>% select(1,2))
```

Ou passando o nome das colunas

```{r}
library(dplyr)

head(del_fil_sel_col %>% select(Coluna1,Coluna2))
```

* Selecionando colunas de acordo com o tipo da variável

Podemos fazer isso com o auxílo do pacote **dplyr**
Como base vamos utilizar o dataframe iris como exemplo, note que temos 4 colunas numéricas e uma factor

```{r, echo=FALSE}
head(iris)
str(iris)
```

* Selecionando colunas que são numéricas apenas

Note que a coluna Species não aparece, pois ela não é numerica e estamos selecionando apenas as que são numéricas

```{r,eval=TRUE, message=FALSE, warning=FALSE, include=TRUE}

library(dplyr)

head(iris) %>% 
  select_if(is.numeric)
```

Caso não queira usar nenhum pacote, também conseguimos fazer a operação usando o R Raiz

```{r}
Filter(is.numeric,head(iris))
```

Se ainda não fucou satisfeito, podemos usar o R Raiz com a function sapply

```{r}
head(iris[,sapply(iris, is.numeric)])
```

Podemos chegar no mesmo objetivo mas ao invés de selecionar as numéricas, podemos selecionar as que NÃO são factor, acrescentando a function **negate** do pacote **purrr**

```{r,eval=TRUE, message=FALSE, warning=FALSE, include=TRUE}

library(dplyr)
library(purrr)

head(iris) %>% 
  select_if(negate(is.factor))
```

* Selecionando colunas com mais de um tipo

Nesse caso precisamos criar uma function dentro do select_if

```{r,eval=TRUE, message=FALSE, warning=FALSE, include=TRUE}

library(dplyr)

head(iris) %>% 
  select_if(function(col) is.numeric(col) |
              is.factor(col))
```

Ou novamente sem utilizar nenhum pacote

```{r}
Filter(function(col) is.numeric(col) |
         is.factor(col),head(iris))
```

E utilizando a function sapply

```{r}
head(iris[,sapply(iris, function(col) is.numeric(col) |
                    is.factor(col))])
```

Cabe a você escolher o jeito que quer usar e a forma mais eficiente para o seu caso!

### 8.9. Excluindo/Filtrando/Selecionando linhas

### 8.10. Levels das variáveis de um dataframe

Novamente podemos utilizar a function **sapply** para esse objetivo, junto com a function **nlevels**

```{r}
data.frame(Level = sapply(iris, nlevels))
```

Com isso podemos ir mais além, por exemplo, pegar os nomes das variáveis que tem mais de um level no factor

```{r}
colnames(iris)[sapply(iris, nlevels) > 1]
```

[Volte ao topo](#abcd)

## 9. Listas

Como já falado anteriormente, uma lista é um objeto que aceita diversos tipos de objetos dentro dela. Por exemplo, o primeio item de uma lista pode ser um vetor, o segundo pode ser um data.frame, o terceiro pode ser uma matriz e assim por diante.

### 9.1. Criando uma lista

Podemos criar uma lista já preenchendo os elementos, nesse caso o primeiro item é uma matriz e o segundo é um vetor

```{r}
list(matriz = matrix(1:10, nrow = 5), 
     vetor = c(1,2,3,4,5))
```

Podemos criar uma lista vazia e ir preenchendo ela aos poucos

```{r}
empty_list = list()
empty_list[[1]] = matrix(1:10, nrow = 5)
empty_list[[2]] = c(1,2,3,4,5)
```

Em seguida podemos nomear os itens dessa lista usando a função names, através de um vetor passamos os nomes que esses elementos vão ter.

```{r}
names(empty_list) = c('matriz','vetor')
```

```{r, echo=FALSE}
empty_list
```

### 9.2. Acessando elementos de uma lista

O primeiro colchete, é referente ao título da lista, o segundo colchete é referente ao conteúdo dela, por exemplo, acessando o primeiro elemento da lista, vemos que o nome é matriz.

```{r}
empty_list[1]
```

Acessando o conteúdo dessa lista, usando a notação de colchete, agora estamos acessando a matriz em si

```{r}
empty_list[[1]]
```

Podemos acessar também utilizando o nome, se estiver nome o conteúdo da lista

```{r}
empty_list$matriz
```

### 9.3. Unindo itens de uma lista

É util as vezes unirmos os itens de uma lista, para isso vamos criar uma nova

```{r}
list_union = list(c(1,2,3,4,5),c(5,6,7,8,9)) 
```

Agora podemos unir tanto em linhas como em colunas, usando a function do.call

* Unindo os itens da lista em um data frame, um embaixo do outro

```{r}
do.call("rbind",list_union)
```

* Unindo os itens da lista em um data frame, um do lado do outro

```{r}
do.call("cbind",list_union)
```

Podemos ainda unir em colunas, itens da lista cujos dataframes tem tamanhos diferentes de linha, observe

```{r}
reduce_merge = list(data.frame(Faixas = c("100 - 200",
                                          "200 - 300",
                                          "300 - 400",
                                          "400 - 500",
                                          "500 - 600",
                                          "600 - 700",
                                          "700 - 800",
                                          "800 - 900",
                                          "900 - 1000"),
                               Score = c("0.002716428",
                                         "0.020077950",
                                         "0.134404157",
                                         "0.307310736",
                                         "0.287941420",
                                         "0.164402976",
                                         "0.061178694",
                                         "0.017597732",
                                         "0.003897484")),
                    data.frame(Faixas = c("0 - 100",
                                          "100 - 200",
                                          "200 - 300",
                                          "300 - 400",
                                          "400 - 500",
                                          "500 - 600",
                                          "600 - 700",
                                          "700 - 800",
                                          "800 - 900",
                                          "900 - 1000"),
                               Score2 = c("0.005478997",
                                          "0.002716428",
                                          "0.020077950",
                                          "0.134404157",
                                          "0.307310736",
                                          "0.287941420",
                                          "0.164402976",
                                          "0.061178694",
                                          "0.017597732",
                                          "0.003897484")))
```

* Usando a função reduce com dataframes de tamanhos distintos, como se fosse um left join

```{r}
Reduce(function(x,y) merge(x, y, all =T),
       reduce_merge)
```

* Unindo diferentes listas através da função append

Basta usarmos a função *append* passando como argumentos nossa primeira e segunda lista.

```{r}
append(empty_list,reduce_merge)
```

### 9.4. Excluindo itens de uma lista

Assim como em um dataframe, basta declararmos o valor null para o elemento da lista que queremos excluir, passando o nome do item da lista ou sua posição.

```{r, eval=FALSE}
reduce_merge[[2]] = NULL
```

### 9.5. Inserindo objetos em uma lista

Se podemos excluir, também podemos adicionar elementos a uma lista, nesse caso, basta chamarmos a lista colocando dentro do colchete o nome do novo item, ou a posição.

```{r}
reduce_merge[['newDataFrame']] = data.frame(Coluna1 = c(7,7,7,7,7))
```

```{r, echo=FALSE}
reduce_merge$newDataFrame
```

```{r}
reduce_merge[[4]] = c(1,2,3,4,5)
```

```{r, echo=FALSE}
reduce_merge[[4]]
```


[Volte ao topo](#abcd)