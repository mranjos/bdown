---
title: A Bíblia do R
author: Michelangelo R. dos Anjos
date: '2019-10-29'
slug: a-biblia-do-r
categories:
  - R
  - Turoriais
tags:
  - R
  - Code
  - Basic
  - Tutorial
editor_options: 
  chunk_output_type: console
output:
  blogdown::html_page:
    toc: true
---

## 1. Introdução

<a name="abcd"> Esse </a> é o primeiro post e o que eu considero o principal e mais importante, pois a ideia de criação do site surgiu por causa de um backup de códigos que eu criei conforme as necessidades iam aparecendo e carregava ele comigo para todo lado para consultar quando precisava. Dessa forma, decidi organizá-lo melhor, upar na internet para facilitar o acesso e compartilhar com mais pessoas que tenham interesse e espero que possa ser útil para mais alguém como é muito importante para mim (já que minha memória não é das melhores :laughing:).

O post estará em constante atualização, pois sempre surge algo novo para aprendermos e a ideia é passar a linguagem R para frente sempre de maneira simples e didática, talvez a organização não fique a das melhores, mas vou procurar me esforçar ao máximo, caso o sumário não fique muito claro, recomendo utilizar o **"Ctrl F"** que sempre me salvou e pode ajudar vocês também.

Por último, antes de começar realmente os códigos, vocês encontraram meio misturado códigos **dplyr** com o **R raiz**, mas será em momentos na qual os códigos possuem a mesma função mas simplesmente podem ser escritos em estruturas diferentes. Acho muito importante saber as diversas maneiras de programar pois existem horas que uma será mais fácil que a outra. Por exemplo, na minha opinião, o **R raiz** é mais fácil para programar rotinas, loop, for, if, while, etc. Já o **dplyr** é mais fácil para acessar, consultar, agrupar, exibir resultados de uma tabela.

[Volte ao topo](#abcd)

***

## 2. Funções de configuração e ajuda.

Antes de começar de fato a entrar na linguagem R, vou deixar algumas funções de configuração e ajuda no R que também são muito importantes e costumo utilizar bastante no dia a dia.

### 2.1. Alterando o formato que as saídas são exibidas.

*Parametros:*

* scipen e digits.

Esses dois parâmetros são os que mais utilizo nas configurações do R, antes mesmo de começar a programar. 

+ O primeiro **scipen** especifica qual saída queremos exibir para os números, se a ciêntifica $e^{10}$ ou os números completos.
+ O segundo **digits** especifica a quantidade de digitos que queremos exibir.

OBS: O número no parâmetro não importa para o **scipen**, apenas o sinal.

* scipen.
+ Negativo: Linguagem ciêntifica é exibida.
+ Positivo: O número é exibido inteiro.

* digits.
+ Número de digitos.

```{r}
options(scipen = -9999, digits = 3)
```

```{r,echo=FALSE}
cat("Saída exibida: ",2.575757575757)
```

```{r}
options(scipen = 1111, digits = 6)
```

```{r,echo=FALSE}
cat("Saída exibida: ",2.575757575757)
```

* datatable.integer64.

```{r}
options(datatable.integer64="numeric")
```

Para que na leitura dos dados utilizando o pacote data.table, o R não entenda valores numéricos como integer64 e sim como numeric.

### 2.2. Funções de ajuda.

Quando queremos saber informações sobre determinada função no R podemos utilizar o comando **help** ou a abreviação **?**.

```{r, eval=FALSE}
help(mean)
?mean
```

Em algumas ocasiões não lembramos o nome da função inteira, apenas uma parte. Ao utilizar o comando **apropos** o **R** lista funções que tem a parte especificada no nome.

```{r}
apropos('mea')
```

Por último e de muita utilidade, conseguimos verificar os símbolos operacionais matemáticos que o **R** utiliza apenas com o comando abaixo.

```{r, eval=FALSE}
help('*')
```

```{r,echo=FALSE}
cat("Saída exibida no Help:
+ x
- x
x + y
x - y
x * y
x / y
x ^ y
x %% y
x %/% y")
```


[Volte ao topo](#abcd)

## 3. Atalhos úteis

* Seleção vertical.
+ Para realizar esse tipo de seleção segure **alt** apertado e selecionando com o mouse, fazemos seleção vertical e podemos alterar tudo de uma vez.
+ Além disso combinamos algumas teclas para facilitar. Ao selecionar verticalmente com o **alt**, apertando **shift + end** o cursor vai para o fim de todas as linhas selecionadas, ou **shift + home** para o cursor ir para o início da linha. Outra possibilidade é utilizar as setas para o lado para selecionar, na maioria das vezes é isso que eu utilizo **shift + -> ou <- **.

* Substituindo palavras no R.
+ Apertando ctrl F assim como no excel, conseguimos substituir todas palavras de uma vez

*Parametros:*

1 - **In selection:** substitui apenas no local selecionado

2 - **Match case:** diferencia maiuscula de minuscula

3 - **Regex:** entende o comando **|** como se fosse **ou**, ou seja operador lógico.

* Refazendo uma ação.
+ Muitos sabem que o **ctrl + z** desfaz uma ação no R, mas em alguns casos acabamos desfazendo mais do que queriamos, para **refazer** algo desfeito existe o comando **ctrl + shift + z** que você pode alterar em **Tools - Modify Keyboard Shortcuts**, o mais utilizado em geral para refazer caso queira alterar é o **ctrl + i**. Outros atalhos também podem ser configurados nessa janela.

[Volte ao topo](#abcd)

## 4. Comandos base úteis.

* Limpando a memória do R.
+ Quando trabalhamos com **loop** ou um código muito grande que vai gerando bases temporrárias pesadas, isso vai sobrecarregando a memória do R, tempos alguns comandos que podem nos ajudar nisso, são eles: **objects**, **ls** e **rm**, .

O comando **objects** e **ls** lista os objetos criados até o momento no R.

```{r,eval=FALSE}
objects()
ls()
```

Já o comando **rm** limpa os objetos criados no R. É possível remover *TODOS* os objetos criados, combiando o comando **rm** com **ls** como vemos abaixo.

```{r,eval=FALSE}
rm(list = ls())
```

Ou podemos excluir apenas alguns objetos de interesse, por exemplo.

```{r,eval=FALSE}
objeto1 = c()
objeto2 = c()
rm(objeto1, objeto2)
```

* Verificando e alterando diretórios.
+ Para verificiar o diretório que estamos trabalhando no R, onde serão salvos os arquivos, as bases entre outras coisas, utilizamos o comando **getwd**. 
+ Para alterar o caminho de um diretório para uma pasta de um projeto específico por exemplo, utilizamos o **setwd**. Outro detalhe é que para especificarmos um caminho no R não utilizamos as barras padrão do windows **C:\\** mas sim as barras duplas, como mostra o exemplo abaixo, ou até mesmo a barra invertida **C:/**

```{r, eval=FALSE}
getwd()
setwd("C:\\Users")
```

* Salvando e carregando arquivos do tipo RData.
+ Os objetos no R podem ser salvos utilizando o comando **save** e carregados utilizando o comando **load**. 
+ **save** - O primeiro parâmetro é o nome do objeto a ser salvo (pode ser mais do que um) e o segundo o diretório que ele será salvo (se não especificar salvará no que já esta configurado) seguido do nome do objeto e sua extenção do r **RData**.
+ **load** - O parâmetro necessário é o diretório que o objeto está salvo seguido do seu nome e sua extenção **RData**.

```{r, eval=FALSE}
objeto1 = c()
objeto2 = c()

save(objeto1,objeto2, file = "C:\\Users\\objeto1.RData")
load(file = "C:\\Users\\objeto1.RData")
```


* Instalando, carregando e descarregando pacotes
+ Para instalar um pacote usamos o **install.packages**
+ Para carregar um pacote usamos o **library**. 
+ Para descarregar um pacote usamos o **detach** ele apenas descarrega o pacote caso o mesmo tenha sido carregado com o **library**.

```{r,eval=FALSE}
install.packages("pacote")
library(pacote)
detach(package:pacote)
```


Não precisamos necessariamente carregar um pacote, basta chamá-lo pelo nome, seguido de **::** e em seguida a função que desejamos utilizar dele, por exemplo:

```{r, eval=FALSE}
dplyr::select()
```

* Verificando os pacotes instalados

Pode não parecer útil, mas em algum momento pode se tornar. O comando abaixo lista todos os pacotes instalados na versão do R que você está utilizando.

```{r,eval=FALSE}
rownames(installed.packages())
```

É muito útil quando criamos funções na qual possui pacotes depententes, nesse caso, verificamos se o pacote está instalado, caso não esteja, instalamos.

```{r,eval=FALSE}
if("pacote" %in% rownames(installed.packages()) == FALSE){
  install.packages("pacote")
}
```

Outra utilidade é quando vamos atualizar o R ou mudar de computador e acabamos perdendo todos os pacotes. Antes de fazer essa alteração de versão ou de computador, podemos rodar o seguinte comando no computador/versão antiga:

```{r,eval=FALSE}
packages = c("gdata",rownames(installed.packages()))
save(packages, file="C:/Temp/Rpackages")
```

Na qual criamos a pasta **temp** anteriormente no nosso computador, salvamos todos os pacotes salvos no objeto **packages** e salvamos esse objeto em nossa pasta **temp**.

Ao trocar de computador/versão, carregamos essa pasta com a gente e usamos o comando para instalar todos os pacotes que estavam instalados para nós.

```{r, eval=FALSE}
load(file = "C:/Temp/Rpackages")
for (p in setdiff(packages, rownames(installed.packages()))){
  install.packages(p)
}
```

* <a name="condicionais">Condicionais no R.</a>
+ **=**  (recebe)
+ **==** (igual)
+ **!=** (diferente)
+ **>**  (maior)
+ **<**  (menor)
+ **>=** (maior igual)
+ **<=** (menor igual)

## 5. Estrutura e criação de objetos.

Os objetos mais utilizados no R por mim pelo menos são vetores, matrizes, data frames e listas, irei mostrar a estrutura de cada um deles e como acessar seus elementos. Para atribuir uma variável a um objeto utilizamos as teclas **<-** ou **=** fica a sua escolha.

### 5.1. Vetores

Para criar um vetor utilizamos a função **c()**:

```{r}
vet_1 = c(7,2,5,9,7)
vet_2 = c("a","b","c")
vet_3 = c(1,"a",5)
vet_4 = c(17,12,15,19,17)
```

Para acessar os elementos de um vetor é simples, basta utilizar o comando **[]** sendo que dentro dele especificamos qual o índice do vetor queremos acessar. Por exemplo, se queremos verificar qual o segundo elemento do vetor 1 **vet_1**, fazemos **vet_1[2]**.

Eu leio esse comando como se fosse **onde**, isso me ajuda muito na parte de filtragem e seleção de dados que veremos mais para frente. Meu conselho então é sempre que ver o símbolo **[]** ler **onde**. Por exemplo **vet_1[2]** leia **vet_1 onde a posição é 2**.

```{r,eval=FALSE}
vet_1[2]
```

```{r,echo=FALSE}
cat("Saída exibida: ",vet_1[2])
```

Em alguns casos é útil nomear os elementos de um vetor, por exemplo

```{r}
names(vet_1) = c('um','dois', 'tres','quatro','cinco')
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1
```

Dessa forma, podemos acessar os elementos dos vetores através do seu nome e começamos introduzir outro conceito que é o de camadas, muito utilizados em listas que iremos ver mais para frente. Temos duas camadas agora então, o título com o conteúdo de cada elemento na primeira camada e o somente o conteúdo daquele elemento na segunda camada.

A primeira camada já vimos como acessar, que é utilizando o comando **[]**, para a segunda camada, basta utilizarmos duas vezes esse comando **[[]]** pronto.

Acesso a primeira camada do primeiro elemento com o título e conteúdo:

```{r,eval=FALSE}
vet_1[1]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[1]
```

Acesso a segunda camada do primeiro elemento com o conteúdo:

```{r, eval=FALSE}
vet_1[[1]]
```

```{r,echo=FALSE}
cat("Saída exibida: ",vet_1[[1]])
```

Para filtrar valores dentro de um vetor utilizamos as condicionais exemplificadas [AQUI](#condicionais), ou até mesmo para comparar e fazer verificações se um vetor é igual ao outro.

* Retornando valores dentro do vetor que são iguais a 7

```{r,eval=FALSE}
vet_1[vet_1 == 7]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[vet_1 == 7]
```

* Retornando valores dentro do vetor que são menores do que 7

```{r,eval=FALSE}
vet_1[vet_1 < 7]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[vet_1 < 7]
```

Outra verificação que podemos fazer é o tamanho do vetor, através da função **length**, ou seja, quantos elementos tem dentro daquele objeto vetor.

```{r, eval=FALSE}
length(vet_1)
```

```{r, echo=FALSE}
cat("Saída exibida: ", length(vet_1))
```

Algumas funções facilitam bastante nossa vida na hora de criar vetores, por exemplo, **vetores de repetição**, **aleatórios** e **sequenciais**

* Vetores de repetição

Repetindo a sequencia de 1 a 5 duas vezes

```{r,eval=FALSE}
rep(1:5, 2)
```

```{r,echo=FALSE}
cat("Saída exibida: ", rep(1:5, 2))
```

Repetindo os números de 1 a 5 duas vezes

```{r,eval=FALSE}
rep(1:5, each=2)
```

```{r,echo=FALSE}
cat("Saída exibida: ", rep(1:5, each=2))
```

* Gerando números aleatorios de acordo com algumas distribuições.

10 números aleatórios normais com média 0 e desvio padrão 1.

```{r}
rnorm(10, mean = 0, sd = 1)
```

10 números aleatórios com distribuição poisson com número esperado de ocorrências e variância iguais a 3.

```{r}
rpois(10,3) #poisson
```

Para a binomial temos algumas situações, primeiros podemos querer realizar 400 jogos, onde cada jogo tem 10 lançamentos de moeda, cuja probabilidade de sucesso é 0.5. Nesse caso esperamos que em média, o número de sucessos seja aproximadamente 5, como modemos ver abaixo:

```{r,eval=FALSE}
rbinom(400, 10, 0.5)
```

```{r}
mean(rbinom(400, 10, 0.5))
```

Dessa forma se fizemos uma rodada de lançamento de moedas, onde cada rodada tem 10 jogos e somamos o número de sucessos com probabilidade 0.5 cada, tem o mesmo valor esperado do que somar 10 rodadas com 1 lançamento cada, cuja resposta é 0 para fracasso e 1 para sucesso e com probabilidade 0.5 de sucesso em cada lançamento.

```{r,eval=FALSE}
rbinom(1, 10, 0.5)
```

```{r,echo=FALSE}
cat("Saída exibida: ", rbinom(1, 10, 0.5))
```

```{r,eval=FALSE}
sum(rbinom(10, 1, 0.5))
```

```{r,echo=FALSE}
cat("Saída exibida: ", sum(rbinom(10, 1, 0.5)))
```

Mais usual é gerar números aleatórios com a mesma probabilidade de sucesso utilizando a distribuição uniforme, nesse casos podemos gerar 10 números na qual o mínimo é 1 e o máximo é 10.

```{r}
runif(10,min = 1, max = 10) #uniforme 
```

```{r,echo=FALSE}
cat("Saída exibida: ", runif(10,min = 1, max = 10))
```

A mesma lógica pode ser usada mas agora gerando apenas números inteiros através da função sample, gerando 10 números de -10 a 10.

```{r,eval=FALSE}
sample(-10:10, 10)
```

```{r,echo=FALSE}
cat("Saída exibida: ", sample(-10:10, 10))
```

Além disso, utilizando o parâmetro **replace** podemos repetir números

```{r,eval=FALSE}
sample(0:10, 10,replace = T)
```

```{r,echo=FALSE}
cat("Saída exibida: ", sample(0:10, 10,replace = T))
```

Com esse comando podemos sortear nomes também. Para isso, basta criarmos um vetor de nomes, fora ou dentro do comando, e especificar quantos nomes queremos que seja sorteados.

```{r,eval=FALSE}
sample(c("João","Maria","José","Pedro","Julieta"), 2)
```

```{r,echo=FALSE}
cat("Saída exibida: ", sample(c("João","Maria","José","Pedro","Julieta"), 2))
```

* Vetores sequenciais pulando de acordo com o intervalo desejado.

Muito útil também é gerar valores sequencias pulando uma determinada quantia de valores, para isso, usamos a função **seq**, onde queremos gerar valores de 1 a 10, pulando de 0.5 em 0.5 sequencialmente.

```{r,eval=FALSE}
seq(1,10,0.5)
```

```{r,echo=FALSE}
cat("Saída exibida: ", seq(1,10,0.5))
```

* Criando uma semente para os valores aleátorios.

Em muitas situações queremos replicar estudos de simulação com valores aleatórios, para isso, podemos criar uma semente, e dessa maneira os números aleatórios iram se repetir até mesmo em outro computador. O comando que faz isso é o **set.seed**, onde o parâmetro dentro da função tem que ser o mesmo nas replicações.

```{r,eval=FALSE}
set.seed(57)
```

* Operações com vetores

Podemos realizar operações com vetores, como somar, subtrair, multiplicar e dividir.

```{r,eval=FALSE}
vet_1 + vet_4
vet_1 - vet_4
vet_1 * vet_4
vet_1 / vet_4
4 * vet_1
```

### 5.2. Matrizes

Matrizes seguem a mesma lógica de vetores, porém, com mais dimensões, nós trabalharemos sempre com matrizes de duas dimensões, para criar a matriz, elas também são Semelhante ao data.frame, exceto que cada elemento deve ser o mesmo tipo e mais comumente todos sendo números. As funções que funcionam com data.frame também devem funcionar com a matriz. Eu particularmente utilizo matrizes apenas em funções como for, while, para ir preenchendo, em geral utilizo mais data.frames

* Sintaxe para criação de matrizes

Para criar matrizes é simples e tem diversas maneiras. A primeira é no primeiro parâmetro adicionar o vetor de valores, o segundo parâmetro o número de linhas e o terceiro parâmetro o número de colunas.

```{r}
matrix1 = matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3,ncol = 3)
```

```{r,echo=FALSE}
cat("Saída exibida:")
matrix1
```

O segundo jeito é especificar somente o vetor de valores e o segundo parâmetro que é o número de linhas de cada coluna, dessa forma, os valores vão se alocando sozinhos na primeira coluna até o quinto elemento por exemplo e depois vão para a segunda.

```{r}
matrix2 <- matrix(1:10, nrow = 5)
```

```{r,echo=FALSE}
cat("Saída exibida:")
matrix2
```

Geralmente nos looping criamos inicialmente uma matriz de NA, para isso, basta deixarmos o primeiro parâmetro vazio

```{r,echo=FALSE}
matrix3 <- matrix(,nrow = 3,ncol = 3)
```

```{r}
cat("Saída exibida:")
matrix3
```

Como vimos por padão o R vai adicionando os elementos por linha, podemos alterar isso para colunas adicionando o parâmetro **byrow**

```{r}
matrix4 <- matrix(1:10, nrow = 5, byrow = TRUE)
```

```{r,echo=FALSE}
cat("Saída exibida:")
matrix4
```

* Multiplicando de matrizes

Para multiplicar matrizes utilizamos o operador %*%.

```{r, eval=FALSE}
matrix1 %*% matrix1
```

* Transpor matrizes

Para transpor uma matriz basta usar a função **t()**

```{r,eval=FALSE}
t(matrix1)
```

* Acessando elementos de uma matriz

Para acessar elementos de uma matriz é muito simples, assim como vetor, usamos operador **[]**, porém em uma matríz temos linhas e colunas e para separar isso, vamos utilizar uma vírgula, ficando o operador dessa forma **[,]**. Antes da vírgula é o acesso a linha e depois da vírgula é o acesso a coluna.

Dessa forma, para acessar a primeira linha de uma matriz utilizamos **[1,]**.

```{r, eval=FALSE}
matrix1[1,]
```

```{r,echo=FALSE}
cat("Saída exibida: ", matrix1[1,])
```

Para acessar a primeira coluna de uma matriz utilizamos **[,1]**

```{r,eval=FALSE}
matrix1[,1]
```

```{r,echo=FALSE}
cat("Saída exibida: ", matrix1[,1])
```

Para acessar um elemento da matriz passamos as coordenadas, por exemplo, queremos o elemento que está na primeira linha da segunda coluna, fazemos então **[1,2]**.

```{r,eval=FALSE}
matrix1[1,2]
```

```{r,echo=FALSE}
cat("Saída exibida: ", matrix1[1,2])
```

Esses conceitos de acesso são muito importantes e você vai utilizar o tempo todo no R, para vetores, matrizes, data.frames e listas.

[Volte ao topo](#abcd)

### 5.3. Tipos de objetos

Ja vimos alguns tipos de objetos que o R possui, vetores e matrizes. Dentre os vetores podemos ter 3 tipos principais, **numeric**, **character** e **factor**. Temos as matrizes que basicamente são conjuntos de vetores e alguns principais que veremos mais para frente que são **data.frames** e **lists**. Mas como saber que tipo de objeto estamos trabalhando? Para isso o R possui uma função chamada **class**. Observe:

* Vetor numérico

```{r,eval=FALSE}
class(c(1,2,3,4,5))
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(c(1,2,3,4,5)))
```

Podemos arredondar valores numéricos utilizando algumas funções no R, as mais comuns são:

* **round** (Arrendondamento tradicional)

Podemos especificar no segundo argumento o número de casa decimais que queremos e onde ele irá arredondar.

```{r}
round(1.5757, 2)
```

* **trunc** (Corta as casas decimais)

```{r}
trunc(1.5757)
```

* **ceiling** (Arredonda o valor pra cima)

```{r}
ceiling(1.5757)
```

* **floor** (Arredonda o valor pra baixo)

```{r}
floor(1.5757)
```

* Vetor character

Quando misturamos numeros com letras, o R entende como vetor de caracteres. Caso o vetor seja convertido para numeric, os caracteres assumirão valores nulos.

```{r,eval=FALSE}
class(c("a","b","1","3"))
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(c("a","b","1","3")))
```

* Vetor factor

É um tipo de vetor para lidar com variáveis categóricas. Ele facilita a ordenação de vetores de textos e são muito utilizados em modelagens, criação de gráficos, etc.

```{r,eval=FALSE}
class(factor(c("a","b","1","3")))
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(factor(c("a","b","1","3"))))
```

Para sabemos quantos níveis/levels tem um vetor de fator, usamos a função **nlevels** que seria basicamente o mesmo do que contar os valores únicos de um vetor de caracteres. Observe abaixo que temos 4 elementos no vetor mas apenas 3 níveis.

```{r}
nlevels(factor(c("a","a","1","3")))
```


* Matrizes

```{r,eval=FALSE}
class(matrix())
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(matrix()))
```

* Data frames

Data frames nada mais são do que tabelas, com linhas e colunas. é praticamente uma matriz com rótulos de colunas. Também são conjunto de vetores, mas diferente de matrizes, cada coluna pode ser um tipo, por exemplo, a coluna 1 pode ser numérica, a coluna 2 pode ser character e a coluna 3 pode ser fator, na matriz ou são numericos ou são caracteres, não temos essa mistura e convenhamos, essa mistura é o que mais ocorre na vida real, pois temois informações como UF, Sexo, Idade, Peso, tudo junto em uma mesma tabela.

```{r,eval=FALSE}
class(data.frame())
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(data.frame()))
```

Poré, em um data.frame quando temos muitas colunas, fica praticamente inviável ficar dando um **class** uma por uma, pensando nisso o R possui uma função chamada **str** que nos mostra os tipos de de cada coluna.

```{r}
df_class = data.frame(col1 = c(7,2,7,56), col2 = c("a","b","c","d"))
```

```{r}
str(df_class,list.len=ncol(df_class))
```

Porém essa não é uma forma muito apresentavel de se ver, podemos fazer uso de outras funções para verificarmos o tipo de cada coluna, caso queiramos filtrar e verificar quais são numéricas, coisas do tipo.

```{r}
Class_DF = data.frame(Variavel = names(sapply(df_class, class)),
                      Classe  = sapply(df_class, class))

row.names(Class_DF) = NULL

```

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE}
library(knitr)
library(kableExtra)

kable(Class_DF, align = "c") %>% kable_styling(bootstrap_options = "striped", full_width = F,position = "center")
```

* Listas

A lista, é um objeto que aceita diversos tipos de objetos dentro dela. Por exemplo, o primeio item de uma lista pode ser um vetor, o segundo pode ser um data.frame, o terceiro pode ser uma matriz e assim por diante.

```{r,eval=FALSE}
class(list())
```

```{r,echo=FALSE}
cat("Saída exibida: ", class(list()))
```

Veremos listas e data.frames de forma mais detalhada em capitulos específicos, pois são os tipos de objetos mais trabalhados, pelo menos comigo.

## 6. Operações matemáticas básicas

Temos abaixo as mais funções matemáticas/estatísticas básicas mais utilizadas, tais como: **log na base e**, **exponencial**, **máximo**, **mínimo**, **soma**, **média**, **mediana**, **variância**, **desvio padrão** e **correlação**, respectivamente:

```{r,eval=FALSE}
log(1)
exp(1)
```

O máximo e mínimo pode ser calculado entre mais de um vetor
```{r,eval=FALSE}
max(vet_1)
max(vet_1,vet_4)

min(vet_1)
min(vet_1,vet_4)
```

```{r,eval=FALSE}
sum(vet_1)
mean(vet_1)
median(vet_1)
var(vet_1)
sd(vet_1)
```

Para a correlação pode ser especificada qual metodologia para calcular, **pearson**, **kendall** ou **spearman**.
```{r,eval=FALSE}
cor(vet_1,vet_4, method = "pearson")
cor(vet_1,vet_4, method = "kendall")
cor(vet_1,vet_4, method = "spearman")
```

[Volte ao topo](#abcd)

```{r}
class(vet_1)
class(vet_2)
class(vet_3)
class(vet_4)
```

Transformando valores de um vetor em factor, numeros e caracteres

```{r,eval=FALSE}
as.factor(vet_1)
as.numeric(vet_2)
as.character(vet_3)
```

## 7. Exibindo valores e textos na tela

Temos algumas opções, as que eu mais utilizo são:

* CAT.

```{r}
cat("Hello World \nLinha de baixo")
```

OBS: O comando \n pula linha

* PRINT.

```{r}
print("Hello World")
```

* WARNING.

```{r}
warning("Hello World")
```

## 8. Data Frames

[Volte ao topo](#abcd)

## 9. Listas

Como já falado anteriormente, uma lista é um objeto que aceita diversos tipos de objetos dentro dela. Por exemplo, o primeio item de uma lista pode ser um vetor, o segundo pode ser um data.frame, o terceiro pode ser uma matriz e assim por diante.

### 9.1. Criando uma lista

Podemos criar uma lista já preenchendo os elementos, nesse caso o primeiro item é uma matriz e o segundo é um vetor

```{r}
list(matriz = matrix(1:10, nrow = 5), 
     vetor = c(1,2,3,4,5))
```

Podemos criar uma lista vazia e ir preenchendo ela aos poucos

```{r}
empty_list = list()
empty_list[[1]] = matrix(1:10, nrow = 5)
empty_list[[2]] = c(1,2,3,4,5)
```

Em seguida podemos nomear os itens dessa lista

```{r}
names(empty_list) = c('matriz','vetor')
```

```{r, echo=FALSE}
empty_list
```

[Volte ao topo](#abcd)