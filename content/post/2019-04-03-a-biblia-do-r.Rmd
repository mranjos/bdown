---
title: A Bíblia do R
author: Michelangelo R. dos Anjos
date: '2019-04-07'
slug: a-biblia-do-r
categories:
  - R
  - Turoriais
tags:
  - R
  - Code
  - Basic
  - Tutorial
editor_options: 
  chunk_output_type: console
output:
  blogdown::html_page:
    toc: true
---

## 1. Introdução

<a name="abcd"> Esse </a> é o primeiro post e o que eu considero o principal e mais importante, pois a ideia de criação do site surgiu por causa de um backup de códigos que eu criei conforme as necessidades iam aparecendo e carregava ele comigo para todo lado para consultar quando precisava. Dessa forma, decidi organizá-lo melhor, upar na internet para facilitar o acesso e compartilhar com mais pessoas que tenham interesse e espero que possa ser útil para mais alguém como é muito importante para mim (já que minha memória não é das melhores :laughing:).

O post estará em constante atualização, pois sempre surge algo novo para aprendermos e a ideia é passar a linguagem R para frente sempre de maneira simples e didática, talvez a organização não fique a das melhores, mas vou procurar me esforçar ao máximo, caso o sumário não fique muito claro, recomendo utilizar o **"Ctrl F"** que sempre me salvou e pode ajudar vocês também.

Por último, antes de começar realmente os códigos, vocês encontraram meio misturado códigos **dplyr** com o **R raiz**, mas será em momentos na qual os códigos possuem a mesma função mas simplesmente podem ser escritos em estruturas diferentes. Acho muito importante saber as diversas maneiras de programar pois existem horas que uma será mais fácil que a outra. Por exemplo, na minha opinião, o **R raiz** é mais fácil para programar rotinas, loop, for, if, while, etc. Já o **dplyr** é mais fácil para acessar, consultar, agrupar, exibir resultados de uma tabela.

[Volte ao topo](#abcd)

***

## 2. Funções de configuração e ajuda.

Antes de começar de fato a entrar na linguagem R, vou deixar algumas funções de configuração e ajuda no R que também são muito importantes e costumo utilizar bastante no dia a dia.

### 2.1. Alterando o formato que as saídas são exibidas.

*Parametros:*

* scipen e digits.

Esses dois parâmetros são os que mais utilizo nas configurações do R, antes mesmo de começar a programar. 

  + O primeiro **scipen** especifica qual saída queremos exibir para os números, se a ciêntifica $e^{10}$ ou os números completos.
  + O segundo **digits** especifica a quantidade de digitos que queremos exibir.
  
OBS: O número no parâmetro não importa para o **scipen**, apenas o sinal.

* scipen.
  + Negativo: Linguagem ciêntifica é exibida.
  + Positivo: O número é exibido inteiro.

* digits.
  + Número de digitos.
  
```{r}
options(scipen = -9999, digits = 3)
```

```{r,echo=FALSE}
cat("Saída exibida: ",2.575757575757)
```


```{r}
options(scipen = 1111, digits = 6)
```

```{r,echo=FALSE}
cat("Saída exibida: ",2.575757575757)
```

### 2.2. Funções de ajuda.

Quando queremos saber informações sobre determinada função no R podemos utilizar o comando **help** ou a abreviação **?**.

```{r, eval=FALSE}
help(mean)
?mean
```

Em algumas ocasiões não lembramos o nome da função inteira, apenas uma parte. Ao utilizar o comando **apropos** o **R** lista funções que tem a parte especificada no nome.

```{r}
apropos('mea')
```

Por último e de muita utilidade, conseguimos verificar os símbolos operacionais matemáticos que o **R** utiliza apenas com o comando abaixo.

```{r, eval=FALSE}
help('*')
```

```{r,echo=FALSE}
cat("Saída exibida no Help:
+ x
- x
x + y
x - y
x * y
x / y
x ^ y
x %% y
x %/% y")
```


[Volte ao topo](#abcd)

## 3. Atalhos úteis

* Seleção vertical.
  + Para realizar esse tipo de seleção segure **alt** apertado e selecionando com o mouse, fazemos seleção vertical e podemos alterar tudo de uma vez.
  + Além disso combinamos algumas teclas para facilitar. Ao selecionar verticalmente com o **alt**, apertando **shift + end** o cursor vai para o fim de todas as linhas selecionadas, ou **shift + home** para o cursor ir para o início da linha. Outra possibilidade é utilizar as setas para o lado para selecionar, na maioria das vezes é isso que eu utilizo **shift + -> ou <- **.
  
* Substituindo palavras no R.
  + Apertando ctrl F assim como no excel, conseguimos substituir todas palavras de uma vez

*Parametros:*

1 - **In selection:** substitui apenas no local selecionado

2 - **Match case:** diferencia maiuscula de minuscula

3 - **Regex:** entende o comando **|** como se fosse **ou**, ou seja operador lógico.

* Refazendo uma ação.
  + Muitos sabem que o **ctrl + z** desfaz uma ação no R, mas em alguns casos acabamos desfazendo mais do que queriamos, para **refazer** algo desfeito existe o comando **ctrl + shift + z** que você pode alterar em **Tools - Modify Keyboard Shortcuts**, o mais utilizado em geral para refazer caso queira alterar é o **ctrl + i**. Outros atalhos também podem ser configurados nessa janela.

[Volte ao topo](#abcd)

## 4. Comandos base úteis.

* Limpando a memória do R.
  + Quando trabalhamos com **loop** ou um código muito grande que vai gerando bases temporrárias pesadas, isso vai sobrecarregando a memória do R, tempos alguns comandos que podem nos ajudar nisso, são eles: **objects**, **ls** e **rm**, .

O comando **objects** e **ls** lista os objetos criados até o momento no R.

```{r,eval=FALSE}
objects()
ls()
```

Já o comando **rm** limpa os objetos criados no R. É possível remover *TODOS* os objetos criados, combiando o comando **rm** com **ls** como vemos abaixo.

```{r,eval=FALSE}
rm(list = ls())
```

Ou podemos excluir apenas alguns objetos de interesse, por exemplo.

```{r,eval=FALSE}
objeto1 = c()
objeto2 = c()
rm(objeto1, objeto2)
```

* Verificando e alterando diretórios.
  + Para verificiar o diretório que estamos trabalhando no R, onde serão salvos os arquivos, as bases entre outras coisas, utilizamos o comando **getwd**. 
  + Para alterar o caminho de um diretório para uma pasta de um projeto específico por exemplo, utilizamos o **setwd**. Outro detalhe é que para especificarmos um caminho no R não utilizamos as barras padrão do windows **C:\\** mas sim as barras duplas, como mostra o exemplo abaixo, ou até mesmo a barra invertida **C:/**

```{r, eval=FALSE}
getwd()
setwd("C:\\Users")
```

* Salvando e carregando arquivos do tipo RData.
  + Os objetos no R podem ser salvos utilizando o comando **save** e carregados utilizando o comando **load**. 
  + **save** - O primeiro parâmetro é o nome do objeto a ser salvo (pode ser mais do que um) e o segundo o diretório que ele será salvo (se não especificar salvará no que já esta configurado) seguido do nome do objeto e sua extenção do r **RData**.
  + **load** - O parâmetro necessário é o diretório que o objeto está salvo seguido do seu nome e sua extenção **RData**.

```{r, eval=FALSE}
objeto1 = c()
objeto2 = c()

save(objeto1,objeto2, file = "C:\\Users\\objeto1.RData")
load(file = "C:\\Users\\objeto1.RData")
```


* Instalando, carregando e descarregando pacotes
  + Para instalar um pacote usamos o **install.packages**
  + Para carregar um pacote usamos o **library**. 
  + Para descarregar um pacote usamos o **detach** ele apenas descarrega o pacote caso o mesmo tenha sido carregado com o **library**.

```{r,eval=FALSE}
install.packages("pacote")
library(pacote)
detach(package:pacote)
```

  
Não precisamos necessariamente carregar um pacote, basta chamá-lo pelo nome, seguido de **::** e em seguida a função que desejamos utilizar dele, por exemplo:
  
```{r, eval=FALSE}
dplyr::select()
```

* Verificando os pacotes instalados

Pode não parecer útil, mas em algum momento pode se tornar. O comando abaixo lista todos os pacotes instalados na versão do R que você está utilizando.

```{r,eval=FALSE}
rownames(installed.packages())
```

É muito útil quando criamos funções na qual possui pacotes depententes, nesse caso, verificamos se o pacote está instalado, caso não esteja, instalamos.

```{r,eval=FALSE}
if("pacote" %in% rownames(installed.packages()) == FALSE){
  install.packages("pacote")
  }
```

Outra utilidade é quando vamos atualizar o R ou mudar de computador e acabamos perdendo todos os pacotes. Antes de fazer essa alteração de versão ou de computador, podemos rodar o seguinte comando no computador/versão antiga:

```{r,eval=FALSE}
packages = c("gdata",rownames(installed.packages()))
save(packages, file="C:/Temp/Rpackages")
```

Na qual criamos a pasta **temp** anteriormente no nosso computador, salvamos todos os pacotes salvos no objeto **packages** e salvamos esse objeto em nossa pasta **temp**.

Ao trocar de computador/versão, carregamos essa pasta com a gente e usamos o comando para instalar todos os pacotes que estavam instalados para nós.

```{r, eval=FALSE}
load(file = "C:/Temp/Rpackages")
for (p in setdiff(packages, rownames(installed.packages()))){
  install.packages(p)
}
```

* <a name="condicionais">Condicionais no R.</a>
  + **=**  (recebe)
  + **==** (igual)
  + **!=** (diferente)
  + **>**  (maior)
  + **<**  (menor)
  + **>=** (maior igual)
  + **<=** (menor igual)

## 5. Estrutura e criação de objetos.

Os objetos mais utilizados no R por mim pelo menos são vetores, matrizes, data frames e listas, irei mostrar a estrutura de cada um deles e como acessar seus elementos. Para atribuir uma variável a um objeto utilizamos as teclas **<-** ou **=** fica a sua escolha.

### 5.1. Vetores

Para criar um vetor utilizamos a função **c()**:

```{r}
vet_1 = c(7,2,5,9,7)
vet_2 = c("a","b","c")
vet_3 = c(1,"a",5)
```

Para acessar os elementos de um vetor é simples, basta utilizar o comando **[]** sendo que dentro dele especificamos qual o índice do vetor queremos acessar. Por exemplo, se queremos verificar qual o segundo elemento do vetor 1 **vet_1**, fazemos **vet_1[2]**.

Eu leio esse comando como se fosse **onde**, isso me ajuda muito na parte de filtragem e seleção de dados que veremos mais para frente. Meu conselho então é sempre que ver o símbolo **[]** ler **onde**. Por exemplo **vet_1[2]** leia **vet_1 onde a posição é 2**.

```{r,eval=FALSE}
vet_1[2]
```

```{r,echo=FALSE}
cat("Saída exibida: ",vet_1[2])
```

Em alguns casos é útil nomear os elementos de um vetor, por exemplo

```{r}
names(vet_1) = c('um','dois', 'tres','quatro','cinco')
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1
```

Dessa forma, podemos acessar os elementos dos vetores através do seu nome e começamos introduzir outro conceito que é o de camadas, muito utilizados em listas que iremos ver mais para frente. Temos duas camadas agora então, o título com o conteúdo de cada elemento na primeira camada e o somente o conteúdo daquele elemento na segunda camada.

A primeira camada já vimos como acessar, que é utilizando o comando **[]**, para a segunda camada, basta utilizarmos duas vezes esse comando **[[]]** pronto.

Acesso a primeira camada do primeiro elemento com o título e conteúdo:

```{r,eval=FALSE}
vet_1[1]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[1]
```

Acesso a segunda camada do primeiro elemento com o conteúdo:

```{r, eval=FALSE}
vet_1[[1]]
```

```{r,echo=FALSE}
cat("Saída exibida: ",vet_1[[1]])
```

Para filtrar valores dentro de um vetor utilizamos as condicionais exemplificadas [AQUI](#condicionais), ou até mesmo para comparar e fazer verificações se um vetor é igual ao outro.

* Retornando valores dentro do vetor que são iguais a 7

```{r,eval=FALSE}
vet_1[vet_1 == 7]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[vet_1 == 7]
```

* Retornando valores dentro do vetor que são menores do que 7

```{r,eval=FALSE}
vet_1[vet_1 < 7]
```

```{r,echo=FALSE}
cat("Saída exibida:")
vet_1[vet_1 < 7]
```

Outra verificação que podemos fazer é o tamanho do vetor, através da função **length**, ou seja, quantos elementos tem dentro daquele objeto vetor.

```{r, eval=FALSE}
length(vet_1)
```

```{r, echo=FALSE}
cat("Saída exibida: ", length(vet_1))
```

### 5.2. Matrizes

### 5.3. Data Frames

### 5.4. Listas

[Volte ao topo](#abcd)

